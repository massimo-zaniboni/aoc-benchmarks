
{-# LANGUAGE ImportQualifiedPost, BlockArguments, LambdaCase, PatternSynonyms, ViewPatterns #-}

-- SPDX-License-Identifier: ISC
-- Copyright (c) 2021 Paolo Martini &lt;mrtnpaolo&#64;protonmail.com&gt;

module Main (main) where

import Data.Char       (isLower,isUpper)
import Data.Set        qualified as S
import Data.Map.Strict qualified as M

import Data.List as L (foldl&apos;)
import Data.Map.Strict qualified as M&apos; (toAscList,fromListWith)

import Data.Set    qualified as S
import Data.IntSet qualified as IS
import Data.Foldable as DF (foldl&apos;)

import Data.Bits (shiftR,(.&amp;.))
import Debug.Trace

import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IM

main =
  do links &lt;- toLinks &lt;$&gt; getInputLines parse 12
     mapM_ print (M.toList links)
     let paths2 = part2 links
     --mapM_ print paths2
     print (length paths2)
  where
    parse = words . map \case &apos;-&apos; -&gt; &apos; &apos;; x -&gt; x
    toLinks inp = M.fromListWith (++) (fixends (asgiven ++ opposite))
      where
        asgiven  = map (\[a,b] -&gt; (a,[b])) inp
        opposite = map (\[a,b] -&gt; (b,[a])) inp
        fixends  = map \case (&quot;end&quot;,_) -&gt; (&quot;end&quot;,[]); x -&gt; x
                 . map \(from,to) -&gt; (from,filter (&quot;start&quot; /=) to)

type Path = [String]

type Links = M.Map String [String]

type Picker = Maybe String
           -&gt; Path
           -&gt; String
           -&gt; [(Path, Maybe String)]

explore :: Picker -&gt; Links -&gt; [Path]
explore p links = paths
  where
    paths = filter complete search

    complete (&quot;end&quot;:_) = True
    complete _         = False

    search = map fst (dfs next ([&quot;start&quot;],Nothing))

    next (path&#64;(here:_),dup) = concatMap allowed (links M.! here)
      where
        allowed there&#64;(t:_)
          | isUpper t = [ (there:path,dup) ]
          | otherwise = p dup path there

pick dup path there
  | there `elem` path = []
  | otherwise         = [ (there:path,dup) ]

part2 = explore pick&apos;

pick&apos; Nothing  = pick2
pick&apos; dup      = pick dup

pick2 path there = [ (there:path,dup) ]
  where
    dup | there `elem` path = Just there | otherwise = Nothing

-- ---------------------------------
-- Utilities

getInput :: (String -&gt; a) -&gt; Int -&gt; IO a
getInput parse day = parse &lt;$&gt;  getContents

getInputLines :: (String -&gt; a) -&gt; Int -&gt; IO [a]
getInputLines parse day = getInput (map parse . lines) day

count :: (a -&gt; Bool) -&gt; [a] -&gt; Int
count p xs = L.foldl&apos; f 0 xs
  where
    f n x | p x = n+1 | otherwise = n

freqs :: (Ord a) =&gt; [a] -&gt; [(a,Int)]
freqs xs = combine [ (x,1) | x &lt;- xs ]
  where
    combine = M&apos;.toAscList . M&apos;.fromListWith (+)

-- --------------------
-- Search

{-# INLINE dfs #-}
dfs :: Ord a =&gt; (a -&gt; [a]) -&gt; a -&gt; [a]
dfs next start = dfsOn id next start

{-# INLINE[0] dfsOn #-}
dfsOn :: Ord r =&gt; (a -&gt; r) -&gt; (a -&gt; [a]) -&gt; a -&gt; [a]
dfsOn repr next start = loop S.empty [start]
  where
    loop _ [] = []
    loop seen (x:xs)
      | r `S.member` seen = loop seen xs
      | otherwise         = x : loop seen&apos; (next x ++ xs)
      where
        r = repr x
        seen&apos; = S.insert r seen

{-# RULES &quot;dfsOn/Int&quot; dfsOn = dfsOnInt #-}
{-# INLINE dfsOnInt #-}
dfsOnInt :: (a -&gt; Int) -&gt; (a -&gt; [a]) -&gt; a -&gt; [a]
dfsOnInt repr next start = loop IS.empty [start]
  where
    loop _ [] = []
    loop seen (x:xs)
      | r `IS.member` seen = loop seen xs
      | otherwise          = x : loop seen&apos; (next x ++ xs)
      where
        r = repr x
        seen&apos; = IS.insert r seen

{-# INLINE bfs #-}
bfs :: Ord a =&gt; (a -&gt; [a]) -&gt; a -&gt; [a]
bfs next start = bfsOn id next [start]

{-# INLINE[0] bfsOn #-}
bfsOn :: Ord r =&gt; (a -&gt; r) -&gt; (a -&gt; [a]) -&gt; [a] -&gt; [a]
bfsOn repr next starts = loop S.empty (D.fromList starts)
  where
    loop _ D.Empty = []
    loop seen (x D.:&lt;| xs)
      | r `S.member` seen = loop seen xs
      | otherwise         = x : loop seen&apos; (D.appendList nexts xs)
      where
        r = repr x
        seen&apos; = S.insert r seen
        nexts = next x

{-# RULES &quot;bfsOn/Int&quot; bfsOn = bfsOnInt #-}
{-# INLINE bfsOnInt #-}
bfsOnInt :: (a -&gt; Int) -&gt; (a -&gt; [a]) -&gt; [a] -&gt; [a]
bfsOnInt repr next starts = loop IS.empty (D.fromList starts)
  where
    loop _ D.Empty = []
    loop seen (x D.:&lt;| xs)
      | r `IS.member` seen = loop seen xs
      | otherwise          = x : loop seen&apos; (D.appendList nexts xs)
      where
        r = repr x
        seen&apos; = IS.insert r seen
        nexts = next x

{-# INLINE astar #-}
astar :: Ord a =&gt; (a -&gt; [(a,Int,Int)]) -&gt; a -&gt; [(a,Int)]
astar next start = astarOn id next start

{-# INLINE astarOn #-}
astarOn :: Ord r =&gt; (a -&gt; r) -&gt; (a -&gt; [(a,Int,Int)]) -&gt; a -&gt; [(a,Int)]
astarOn repr next start = loop S.empty (PQ.singleton 0 (0,start))
  where
    loop _    PQ.Empty               = []
    loop seen ((cost,x) PQ.:&lt;| rest)
      | r `S.member` seen = loop seen rest
      | otherwise         = (x,cost) : loop seen&apos; rest&apos;
      where
        r = repr x
        seen&apos; = S.insert r seen
        rest&apos; = DF.foldl&apos; (\q (p,v) -&gt; PQ.insert p v q) rest nexts
        nexts = [ (cost + y_cost + y_dist,(cost + y_cost,y)) | (y,y_cost,y_dist) &lt;- next x ]

-- -------------------------------
-- Deque

-- | Okasaki purely functional double ended queue
data Deque a = D [a] !Int [a] !Int
  deriving (Show)

pattern Empty &lt;- D [] _ [] _
  where
    Empty = D [] 0 [] 0

pattern (:&lt;|) :: a -&gt; Deque a -&gt; Deque a
pattern x :&lt;| xs &lt;- (popFront -&gt; Just (x,xs))

pattern (:|&gt;) :: Deque a -&gt; a -&gt; Deque a
pattern xs :|&gt; x &lt;- (popBack  -&gt; Just (x,xs))

-- when one list becomes empty we split the other and reverse one half
mkDeque :: Deque a -&gt; Deque a

mkDeque Empty = Empty

mkDeque (D [] 0 b bl) | bl &gt; 1 = D f&apos; fl&apos; b&apos; bl&apos;
  where
    (b&apos;,reverse -&gt; f&apos;) = splitAt half b
    half = bl `shiftR` 1
    rest = half + (bl .&amp;. 1)
    bl&apos; = half
    fl&apos; = rest

mkDeque (D f fl [] 0) | fl &gt; 1 = D f&apos; fl&apos; b&apos; bl&apos;
  where
    (f&apos;,reverse -&gt; b&apos;) = splitAt half f
    half = fl `shiftR` 1
    rest = half + (fl .&amp;. 1)
    fl&apos; = half
    bl&apos; = rest

mkDeque d = d

(&lt;|) :: a -&gt; Deque a -&gt; Deque a
x &lt;| (D f fl b bl) = mkDeque (D (x:f) (fl+1) b bl)
infixr &lt;|

(|&gt;) :: Deque a -&gt; a -&gt; Deque a
(D f fl b bl) |&gt; x = mkDeque (D f fl (x:b) (bl+1))
infixl |&gt;

popFront, popBack :: Deque a -&gt; Maybe (a,Deque a)

popFront (D (x:xs) fl b bl) = Just (x,mkDeque (D xs (fl-1) b bl))
popFront (D _ 0 [x] 1)      = Just (x,Empty)
popFront Empty              = Nothing

popBack  (D f fl (x:xs) bl) = Just (x,mkDeque (D f fl xs (bl-1)))
popBack  (D [x] 1 _ 0)      = Just (x,Empty)
popBack  Empty              = Nothing

singleton :: a -&gt; Deque a
singleton x = D [x] 1 [] 0

fromList :: [a] -&gt; Deque a
fromList xs = mkDeque (D xs (length xs) [] 0)

appendList :: [a] -&gt; Deque a -&gt; Deque a
appendList xs d = foldl (|&gt;) d xs

-- -----------------------
-- PQueue

data PQueue a = PQ (IntMap [a])

pattern Empty :: PQueue a
pattern Empty &lt;- (Advent.PQueue.null -&gt; True)
  where
    Empty = PQ IM.empty

pattern (:&lt;|) :: a -&gt; PQueue a -&gt; PQueue a
pattern v :&lt;| q &lt;- (view -&gt; Just (v,q))

insert :: Int -&gt; a -&gt; PQueue a -&gt; PQueue a
insert k v (PQ m) = PQ (IM.alter f k m)
  where
    f Nothing   = Just [v]
    f (Just vs) = Just (v:vs)

singleton :: Int -&gt; a -&gt; PQueue a
singleton p v = PQ (IM.singleton p [v])

fromList :: [(Int,a)] -&gt; PQueue a
fromList xs = PQ $
  IM.fromListWith (++) [ (p,[v]) | (p,v) &lt;- xs ]

null :: PQueue a -&gt; Bool
null (PQ m) = IM.null m

view :: PQueue a -&gt; Maybe (a,PQueue a)
view (PQ m) =
  do ((p,vs),m&apos;) &lt;- IM.minViewWithKey m
     case vs of
      [] -&gt; error &quot;malformed queue&quot;
      [v] -&gt; Just (v,PQ m&apos;)
      (v:vs) -&gt; p&apos; `seq` Just (v,p&apos;)
        where
          p&apos; = PQ (IM.insert p vs m&apos;)

viewWithPriority :: PQueue a -&gt; Maybe (Int,a,PQueue a)
viewWithPriority (PQ m) =
  do ((p,vs),m&apos;) &lt;- IM.minViewWithKey m
     case vs of
      [] -&gt; error &quot;malformed queue&quot;
      [v] -&gt; Just (p,v,PQ m&apos;)
      (v:vs) -&gt; p&apos; `seq` Just (p,v,p&apos;)
        where
          p&apos; = PQ (IM.insert p vs m&apos;)

instance Show a =&gt; Show (PQueue a) where
  showsPrec prec (PQ m) =
    showParen (prec &gt;= 11) $
    showString &quot;fromList &quot; .
    shows [ (p,v) | (p,vs) &lt;- IM.toList m, v &lt;- vs ]

instance Read a =&gt; Read (PQueue a) where
  readsPrec prec =
    readParen (prec &gt;= 11) $ \s -&gt;
      do (&quot;fromList&quot;,s) &lt;- lex s
         (xs,s)         &lt;- reads s
         pure (fromList xs,s)
